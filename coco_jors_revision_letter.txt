> One reviewer felt that pointing the reader to the documentation is not
> sufficient for a quick understanding on how the software can be used for
> research. My advise is to provide a working (concrete) example of the software
> usage.

- Ok, I added a "Usage example" section to "Quality Control", with a specific
  example.

> Declare that the support mechanisms are provided by the GitHub issue system  (https://github.com/proycon/colibri-core/issues), or other means.

- Added a subsection "Support" to "Quality Control", which explicitly refers to the Github issue tracker as requested


> Please consider the enhancements offered by reviewer G regarding the paper clarity


> I felt it was a bit loose in it’s structure.
> Each of the sections come un-announced without a clear thread that relates them
> to each other. Perhaps some higher-order titles like “Features”,
> “Optimizations”, etc. would help a lot in the readability.                                                                                                                                   
I added higher order prefixes to the various section titles (Features:,
Optimisation:, Parametrisation:) and added some introductory text for the "Implementation & Architecture" section to provide some further glue.
I felt rather constrained, however,  by the JORS template and the unorthodox lack of section numbers. I hope this is an acceptable solution.

- Informed Skipgram Counting: “in the number of tokens” -> you mean skipped
- tokens?.

I mean the the length of the skipgram in general, expressed in tokens, so
skipped + non-skipped tokens. I reworded some things and added more clarification in the text.

Also, later, when you describe possible configurations, could you give                                                                                                                
some examples? 

- I added examples to illustrate this point

> For the algorithms, I would recommend using CamelCase or underscores for more clarity.

- Agreed, added camelcasing for function names in algorithms

> What counts? : “A secondary word occurrence threshold” -> word frequency threshold?.

- Yes, that would be the same. I rather use the term occurrence threshold as it
  refers to absolute counts rather than any normalised frequency.

> Also, the skip type threshold bullet wasn’t entirely clear to me.
> Could you revise it?

- I rephrased some minor parts but I'm not sure what is not clear. The examples
  should hopefully illustrate the point adequately.

> Pattern models: I understand that tries should have a large memory footprint,
but I didn’t quite get what you mean by “strongly linked nature”.

- The footnote should address this. The nodes of the trie are linked obviously,
  which would require a pointer (8 byte on a 64 bit architecture) for every transition between two
  tokens. This gets expensive memory-wise. I did some minor rewording of the
  footnote the paper to clarify this.

> Also, you may want to explain what suffix tries and suffix arrays are (for
> example, I don’t know the latter, so it’s hard to follow the discussion).

- I added a citation for suffix tries and a one-sentence explanation. I also
  added a minor clarification for suffix arrays, but I think a deeper
  explanation would take up too much space and distract from the main topic.
  The suffix arrays are mainly included as I expected readers who were already familiar
  with them to bring them up and wonder how they'd compare to Colibri Core.

> Corpus comparison: “the training corpus, it is therefore asymmetric” ->
revise grammar. 

- Rephrased

> Also, I know what log-likelihood is, but didn’t get what it
> stands for in this context. Perhaps a short formula would clarify?

- Added the formula.




- Relations between patterns: when you say that the reverse index is computed
on the fly, you mean when some “load model” primitive is executed? Does it take
too long? It would be nice to see some experiments on the functionaliti

