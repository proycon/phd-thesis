> One reviewer felt that pointing the reader to the documentation is not
> sufficient for a quick understanding on how the software can be used for
> research. My advise is to provide a working (concrete) example of the software
> usage.

- Ok, I added a "Usage example" section to "Quality Control", with a specific
  example.

> Declare that the support mechanisms are provided by the GitHub issue system  (https://github.com/proycon/colibri-core/issues), or other means.

- Added a subsection "Support" to "Quality Control", which explicitly refers to the Github issue tracker as requested


> Please consider the enhancements offered by reviewer G regarding the paper clarity


> I felt it was a bit loose in it’s structure.
> Each of the sections come un-announced without a clear thread that relates them
> to each other. Perhaps some higher-order titles like “Features”,
> “Optimizations”, etc. would help a lot in the readability.                                                                                                                                   
I added higher order prefixes to the various section titles (Features:,
Optimisation:, Parametrisation:) and added some introductory text for the "Implementation & Architecture" section to provide some further glue.
I felt rather constrained, however,  by the JORS template and the unorthodox lack of section numbers. I hope this is an acceptable solution.
                                                                                                                                                                                         

> For the algorithms, I would recommend using CamelCase or underscores for more clarity.

- Agreed, added camelcasing for function names in algorithms





- Informed Skipgram Counting: “in the number of tokens” -> you mean skipped
tokens?. Also, later, when you describe possibleconigurations, could you give
some examples?
- What counts? : “A secondary word occurrence threshold” -> word frequency
threshold?. Also, the skip type threshold bullet wasn’t entirely clear to me.
Could you revise it?
- Pattern models: I understand that tries should have a large memory footprint,
but I didn’t quite get what you mean by “strongly linked nature”. Also, you may
want to explain what suffix tries and suffix arrays are (for example, I don’t
know the latter, so it’s hard to follow the discussion).
- Corpus comparison: “the training corpus, it is therefore asymmetric” ->
revise grammar. Also, I know what log-likelihood is, but didn’t get what it
stands for in this context. Perhaps a short formula would clarify?
- Relations between patterns: when you say that the reverse index is computed
on the fly, you mean when some “load model” primitive is executed? Does it take
too long? It would be nice to see some experiments on the functionaliti

